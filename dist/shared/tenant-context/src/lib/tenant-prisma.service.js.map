{"version":3,"sources":["../../../../../shared/tenant-context/src/lib/tenant-prisma.service.ts"],"sourcesContent":["import { Injectable, OnModuleDestroy } from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\ninterface PoolConfig {\r\n  max: number;\r\n  idleTimeoutMs: number;\r\n  acquireTimeoutMs: number;\r\n}\r\n\r\nconst DEFAULT_POOL_CONFIG: PoolConfig = {\r\n  max: 10,\r\n  idleTimeoutMs: 30000,\r\n  acquireTimeoutMs: 5000,\r\n};\r\n\r\ninterface TenantConnection {\r\n  client: PrismaClient;\r\n  lastUsed: number;\r\n}\r\n\r\n@Injectable()\r\nexport class TenantPrismaService implements OnModuleDestroy {\r\n  private readonly clients = new Map<string, TenantConnection>();\r\n  private readonly poolConfig: PoolConfig;\r\n  private cleanupInterval: NodeJS.Timeout | null = null;\r\n\r\n  constructor(private readonly configService: ConfigService) {\r\n    this.poolConfig = {\r\n      max: this.configService.get<number>('TENANT_DB_POOL_MAX') ?? DEFAULT_POOL_CONFIG.max,\r\n      idleTimeoutMs: this.configService.get<number>('TENANT_DB_IDLE_TIMEOUT_MS') ?? DEFAULT_POOL_CONFIG.idleTimeoutMs,\r\n      acquireTimeoutMs: this.configService.get<number>('TENANT_DB_ACQUIRE_TIMEOUT_MS') ?? DEFAULT_POOL_CONFIG.acquireTimeoutMs,\r\n    };\r\n\r\n    this.startIdleCleanup();\r\n  }\r\n\r\n  /**\r\n   * Get or create a PrismaClient for the given tenant\r\n   * Uses lazy initialization and connection pooling\r\n   */\r\n  async getClient(tenantId: string): Promise<PrismaClient> {\r\n    const existing = this.clients.get(tenantId);\r\n\r\n    if (existing) {\r\n      existing.lastUsed = Date.now();\r\n      return existing.client;\r\n    }\r\n\r\n    return this.createClient(tenantId);\r\n  }\r\n\r\n  /**\r\n   * Get a PrismaClient synchronously (for middleware use)\r\n   * Note: Will create connection if not exists\r\n   */\r\n  getClientSync(tenantId: string): PrismaClient {\r\n    const existing = this.clients.get(tenantId);\r\n\r\n    if (existing) {\r\n      existing.lastUsed = Date.now();\r\n      return existing.client;\r\n    }\r\n\r\n    const client = this.createClientSync(tenantId);\r\n    return client;\r\n  }\r\n\r\n  private async createClient(tenantId: string): Promise<PrismaClient> {\r\n    const dbUrl = this.getTenantDbUrl(tenantId);\r\n\r\n    const client = new PrismaClient({\r\n      datasources: {\r\n        db: { url: dbUrl },\r\n      },\r\n    });\r\n\r\n    try {\r\n      // Connect with timeout\r\n      const connectPromise = client.$connect();\r\n      const timeoutPromise = new Promise<never>((_, reject) => {\r\n        setTimeout(() => {\r\n          reject(new Error(`Connection acquisition timeout after ${this.poolConfig.acquireTimeoutMs}ms for tenant ${tenantId}`));\r\n        }, this.poolConfig.acquireTimeoutMs);\r\n      });\r\n\r\n      await Promise.race([connectPromise, timeoutPromise]);\r\n\r\n      this.clients.set(tenantId, {\r\n        client,\r\n        lastUsed: Date.now(),\r\n      });\r\n\r\n      return client;\r\n    } catch (error) {\r\n      // Clean up the client on connection failure to prevent memory leak\r\n      await client.$disconnect().catch(() => {\r\n        // Ignore disconnect errors during cleanup\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private createClientSync(tenantId: string): PrismaClient {\r\n    const dbUrl = this.getTenantDbUrl(tenantId);\r\n\r\n    const client = new PrismaClient({\r\n      datasources: {\r\n        db: { url: dbUrl },\r\n      },\r\n    });\r\n\r\n    this.clients.set(tenantId, {\r\n      client,\r\n      lastUsed: Date.now(),\r\n    });\r\n\r\n    // Connect in background - client will auto-connect on first query\r\n    return client;\r\n  }\r\n\r\n  private getTenantDbUrl(tenantId: string): string {\r\n    // Dev mode: use the platform DATABASE_URL for all tenants (single-database mode)\r\n    const devMode = this.configService.get<string>('DEV_MODE') === 'true';\r\n    if (devMode) {\r\n      const platformUrl = this.configService.get<string>('DATABASE_URL');\r\n      if (platformUrl) {\r\n        return platformUrl;\r\n      }\r\n    }\r\n\r\n    const host = this.configService.get<string>('TENANT_DB_HOST') ?? 'localhost';\r\n    const port = this.configService.get<number>('TENANT_DB_PORT') ?? 5432;\r\n    const user = this.configService.get<string>('TENANT_DB_USER') ?? 'postgres';\r\n    const password = this.configService.get<string>('TENANT_DB_PASSWORD') ?? 'postgres';\r\n\r\n    // Tenant database name follows convention: tenant_{tenantId without prefix}\r\n    const dbName = `tenant_${tenantId.replace('tnt_', '')}`;\r\n\r\n    // URL-encode credentials to handle special characters (e.g., @, :, /)\r\n    const encodedUser = encodeURIComponent(user);\r\n    const encodedPassword = encodeURIComponent(password);\r\n\r\n    return `postgresql://${encodedUser}:${encodedPassword}@${host}:${port}/${dbName}?connection_limit=${this.poolConfig.max}`;\r\n  }\r\n\r\n  private startIdleCleanup(): void {\r\n    // Run cleanup every minute\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanupIdleConnections();\r\n    }, 60000);\r\n  }\r\n\r\n  private cleanupIdleConnections(): void {\r\n    const now = Date.now();\r\n\r\n    for (const [tenantId, connection] of this.clients.entries()) {\r\n      if (now - connection.lastUsed > this.poolConfig.idleTimeoutMs) {\r\n        connection.client.$disconnect().catch(() => {\r\n          // Ignore disconnect errors during cleanup\r\n        });\r\n        this.clients.delete(tenantId);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect a specific tenant's client\r\n   */\r\n  async disconnectTenant(tenantId: string): Promise<void> {\r\n    const connection = this.clients.get(tenantId);\r\n    if (connection) {\r\n      await connection.client.$disconnect();\r\n      this.clients.delete(tenantId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the number of active connections\r\n   */\r\n  getActiveConnectionCount(): number {\r\n    return this.clients.size;\r\n  }\r\n\r\n  /**\r\n   * Check if a tenant has an active connection\r\n   */\r\n  hasConnection(tenantId: string): boolean {\r\n    return this.clients.has(tenantId);\r\n  }\r\n\r\n  async onModuleDestroy(): Promise<void> {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n\r\n    // Disconnect all clients\r\n    const disconnectPromises = Array.from(this.clients.values()).map(\r\n      (connection) => connection.client.$disconnect()\r\n    );\r\n\r\n    await Promise.all(disconnectPromises);\r\n    this.clients.clear();\r\n  }\r\n}\r\n"],"names":["TenantPrismaService","DEFAULT_POOL_CONFIG","max","idleTimeoutMs","acquireTimeoutMs","getClient","tenantId","existing","clients","get","lastUsed","Date","now","client","createClient","getClientSync","createClientSync","dbUrl","getTenantDbUrl","PrismaClient","datasources","db","url","connectPromise","$connect","timeoutPromise","Promise","_","reject","setTimeout","Error","poolConfig","race","set","error","$disconnect","catch","devMode","configService","platformUrl","host","port","user","password","dbName","replace","encodedUser","encodeURIComponent","encodedPassword","startIdleCleanup","cleanupInterval","setInterval","cleanupIdleConnections","connection","entries","delete","disconnectTenant","getActiveConnectionCount","size","hasConnection","has","onModuleDestroy","clearInterval","disconnectPromises","Array","from","values","map","all","clear","constructor","Map","Injectable"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}